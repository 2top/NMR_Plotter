import sys
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import os
from pathlib import Path
import threading, time 
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from matplotlib import ticker
from collections import defaultdict

BASE_DIR   = os.path.dirname(os.path.abspath(__file__))
CACHE_FILE = os.path.join(BASE_DIR, "last_scan.txt")

# ---------------------------------------------------------------------------
# Global container used by add_dirs / traverse_directory helpers
# ---------------------------------------------------------------------------
state = {}
existing_data = {}

# --------------------
# Preference Handling
# --------------------
PREF_FILENAME = "preferences.txt"

def get_preferences():
    base_dir = os.path.dirname(os.path.abspath(__file__))
    return {
        "import_dir": base_dir,
        "template_dir": os.path.join(base_dir, "plot_templates"),
        "default_template": os.path.join(base_dir, "plot_templates", "default.txt"),
        "figure_save_dir"  : base_dir,
        "couple_x_limits": "1",            
        "disable_int_norm": "0"
    }

def get_pref(preferences, key, default=""):
    return preferences.get(key, default)

def load_template_file(filepath):
    try:
        with open(filepath, "r") as f:
            for line_number, line in enumerate(f, 1):
                if not line.strip():
                    continue
                if ':' not in line:
                    print(f"Warning: Line {line_number} is malformed (missing colon): {line.strip()}")
                    continue
                key, value = line.strip().split(":", 1)
                if not key or not value:
                    print(f"Warning: Line {line_number} has empty key or value: {line.strip()}")
                    continue
                if key in state:
                    if isinstance(state[key], tk.Entry):
                        state[key].delete(0, tk.END)
                        state[key].insert(0, value)
                    elif isinstance(state[key], tk.StringVar):
                        state[key].set(value)
    except Exception as e:
        print(f"Error loading default template: {e}")

def load_preferences():
    defaults = get_preferences()
    preferences = defaults.copy()
    try:
        with open(os.path.join(defaults["import_dir"], PREF_FILENAME), "r") as f:
            for line in f:
                if "=" in line:
                    key, value = line.strip().split("=", 1)
                    if key in preferences:
                        preferences[key] = value
    except Exception as e:
        print(f"Warning: Could not read preferences.txt. Using defaults. Reason: {e}")
    return preferences

def save_preferences(preferences):
    try:
        base_dir = os.path.dirname(os.path.abspath(__file__))  # <-- always save here
        with open(os.path.join(base_dir, PREF_FILENAME), "w") as f:
            for key, value in preferences.items():
                f.write(f"{key}={value}\n")
        return True
    except Exception as e:
        print(f"Error saving preferences: {e}")
        return False

def _init_status_bar(parent_frame):
    """
    Adds a one-line status bar at the bottom of the given frame (e.g. Data Import frame).
    Stores its StringVar in state['status_var'] for global access.
    """
    status_var = tk.StringVar(value="")
    status_lbl = ttk.Label(parent_frame, textvariable=status_var, anchor='w')
    status_lbl.grid(row=99, column=0, columnspan=10, sticky="ew", padx=5, pady=2)
    state['status_var'] = status_var

def _init_tpl_status_bar(parent_frame):
    tpl_status = tk.StringVar(value="")
    lbl = ttk.Label(parent_frame, textvariable=tpl_status, anchor="w")
    lbl.grid(row=99, column=0, columnspan=10, sticky="ew", padx=5, pady=(2,0))
    state['tpl_status_var'] = tpl_status

_tpl_clear_job = None
def set_tpl_status(msg, duration=3000):
    global _tpl_clear_job
    state['tpl_status_var'].set(msg)

    if _tpl_clear_job:
        app.after_cancel(_tpl_clear_job)
    _tpl_clear_job = app.after(duration, lambda: state['tpl_status_var'].set(""))


_status_clear_job = None  # global tracker
def set_status(msg, duration=None):
    """Set the status bar message. Optionally clear after duration (ms)."""
    global _status_clear_job

    state['status_var'].set(msg)

    if _status_clear_job:
        app.after_cancel(_status_clear_job)
        _status_clear_job = None

    if duration:
        _status_clear_job = app.after(duration, clear_status)

def clear_status():
    """Manually clears the status bar."""
    global _status_clear_job

    state['status_var'].set("")
    if _status_clear_job:
        app.after_cancel(_status_clear_job)
        _status_clear_job = None

def _save_dir_cache(top_dir: str, ascii_list: list[str]):
    """
    Save or update one directory‚Äôs scan in last_scan.txt.
    If *top_dir* already exists in the cache, its block is **replaced**.
    """
    # ---------- read existing blocks ----------
    blocks: dict[str, set[str]] = {}
    if os.path.exists(CACHE_FILE):
        with open(CACHE_FILE, "r", encoding="utf-8") as fh:
            cur_top = None
            for ln in fh:
                line = ln.rstrip("\n")
                if line.startswith("TOP:"):
                    cur_top = line[4:]
                    blocks[cur_top] = set()
                elif cur_top and line:
                    blocks[cur_top].add(line)

    # ---------- overwrite *only* this directory ----------
    blocks[top_dir] = set(ascii_list)          # <- overwrite, no .update()

    # ---------- write back ----------
    with open(CACHE_FILE, "w", encoding="utf-8") as fh:
        for td, paths in blocks.items():
            fh.write(f"TOP:{td}\n")
            for p in sorted(paths):
                fh.write(p + "\n")

def _load_dir_cache() -> list[tuple[str, list[str]]] | None:
    """Return [(top_dir, [ascii1 ‚Ä¶]), ‚Ä¶] or None if the file is absent/empty."""
    if not os.path.exists(CACHE_FILE):
        return None

    blocks = []
    with open(CACHE_FILE, "r", encoding="utf-8") as fh:
        cur_top, cur_paths = None, []
        for ln in fh:
            line = ln.rstrip("\n")
            if line.startswith("TOP:"):
                if cur_top:
                    blocks.append((cur_top, cur_paths))
                cur_top, cur_paths = line[4:], []
            elif line:
                cur_paths.append(line)
        if cur_top:
            blocks.append((cur_top, cur_paths))

    return blocks or None


# --------------------
# Preferences Dialog
# --------------------
class PreferencesDialog(tk.Toplevel):
    def __init__(self, master, preferences, on_save_callback):
        super().__init__(master)
        self.transient(master)  # keep dialog on top of parent
        self.grab_set()         # make dialog modal (prevent interaction with main window)
        self.title("Preferences")
        self.preferences = preferences.copy()
        self.modified = False
        self.on_save_callback = on_save_callback

        self.vars = {
            key: tk.StringVar(value=value)
            for key, value in preferences.items()
        }

        self._build_gui()

    def _build_gui(self):
        row = 0
        for key, label_text in [
            ("import_dir", "Default starting directory for data import"),
            ("template_dir", "Default directory for plot templates"),
            ("default_template", "Default plot template file"),
            ("figure_save_dir", "Default directory to save figures")
        ]:
            ttk.Label(self, text=label_text).grid(row=row, column=0, sticky="w", padx=10, pady=5)
            entry = ttk.Entry(self, textvariable=self.vars[key], width=60)
            entry.grid(row=row, column=1, padx=5, pady=5)

            browse_button = ttk.Button(self, text="Browse", command=lambda k=key: self.browse(k))
            browse_button.grid(row=row, column=2, padx=5)
            row += 1

        ttk.Separator(self, orient="horizontal").grid(row=row, column=0, columnspan=3,
                                             sticky="ew", pady=5)
        row += 1

        self.chk_couple = tk.IntVar(value=int(self.vars["couple_x_limits"].get()))
        ttk.Checkbutton(self, text="Couple x-masking limits to x-limits",
                        variable=self.chk_couple, command=self.on_change).grid(
                        row=row, column=0, columnspan=3, sticky="w", padx=10)
        row += 1

        self.chk_norm   = tk.IntVar(value=int(self.vars["disable_int_norm"].get()))
        ttk.Checkbutton(self, text="Disable intensity normalization of plotted spectra",
                        variable=self.chk_norm, command=self.on_change).grid(
                        row=row, column=0, columnspan=3, sticky="w", padx=10)
        row += 1

        self.save_btn = ttk.Button(self, text="Save Preferences", command=self.save, state='disabled')
        self.save_btn.grid(row=row, column=0, columnspan=3, pady=15)

        for var in self.vars.values():
            var.trace_add("write", self.on_change)

    def browse(self, key):
        if key in ("import_dir", "template_dir", "figure_save_dir"):
            new_path = filedialog.askdirectory(initialdir=BASE_DIR)
        elif key == "default_template":
            new_path = filedialog.askopenfilename(
                initialdir=BASE_DIR,
                filetypes=[("Text files", "*.txt")])
        else:  # fallback
            new_path = filedialog.askopenfilename(
                initialdir=BASE_DIR,
                filetypes=[("Text files", "*.txt")])

        if new_path:
            self.vars[key].set(new_path)

    def on_change(self, *args):
        self.modified = True
        self.save_btn.config(state="normal")

    def save(self):
        updated = {k: v.get() for k, v in self.vars.items()}
        updated["couple_x_limits"] = str(self.chk_couple.get())
        updated["disable_int_norm"] = str(self.chk_norm.get())
        success = save_preferences(updated)
        if success:
            self.on_save_callback(updated)        # updates app.preferences
            self.master._apply_coupled_limits()   # ‚Üê hook-up: refresh widgets NOW
            self.destroy()

# ---------------------------------------------------------------------------
#  Custom toolbar so ‚ÄúSave‚Äù starts in preferences["figure_save_dir"]
# ---------------------------------------------------------------------------
class CustomNavigationToolbar(NavigationToolbar2Tk):
    def save_figure(self, *args):            # overrides the stock method
        default_dir = app.preferences.get("figure_save_dir", ".")
        filetypes = [('PNG', '*.png'),
                     ('PDF', '*.pdf'),
                     ('PostScript', '*.ps'),
                     ('EPS', '*.eps'),
                     ('SVG', '*.svg')]
        filename = filedialog.asksaveasfilename(
            title="Save the figure",
            defaultextension=".png",
            filetypes=filetypes,
            initialdir=default_dir
        )
        if filename:
            # honour DPI set by user via the backend
            self.canvas.figure.savefig(filename, dpi=self.canvas.figure.dpi)

# ---------------------------------------------------------------------------
# Main GUI class 
# ---------------------------------------------------------------------------
class NMRPlotterApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.preferences = load_preferences()
        self.pref_window = None  # Track if a PreferencesDialog is already open
        self.title("NMR Plotter")
        self._init_styles()
        # one place to keep spectra and widget handles
        self.existing_data: dict[str, pd.DataFrame] = {}
        self.widgets: dict[str, tk.Widget] = {}    # widget registry 

        self._build_gui()

        # ---- choose a sensible start size: 60 % of screen, but never smaller than 900√ó600 ----
        self.update_idletasks()                      # finish geometry calculations
        scr_w, scr_h = self.winfo_screenwidth(), self.winfo_screenheight()
        w = max(900, int(scr_w * 0.60))
        h = max(600, int(scr_h * 0.60))
        self.geometry(f"{w}x{h}")

        default_template = self.preferences.get("default_template")
        if default_template and os.path.isfile(default_template):
            load_template_file(default_template)
        
        self.protocol("WM_DELETE_WINDOW", self.on_closing)

    def _init_styles(self):
            style = ttk.Style(self)

            # On Windows the "clam" theme is easiest to colour; remove the next line on macOS/Linux if you prefer
            # style.theme_use("clam")            

            # ---------- base look ----------
            style.configure("Plot.TButton",
                            foreground="#C91E3A",          # light-blue text
                            background=style.lookup("TButton", "background"),
                            font=("Helvetica", 10, "bold"),
                            borderwidth=1)

            # ---------- dynamic states ----------
            style.map("Plot.TButton",
                    foreground=[("active",   "#98162C"),   # darker blue on hover/press
                                ("disabled", "#D48C96")],  # grey-blue when disabled
                    background=[("disabled",
                                style.lookup("TButton", "background"))])  # keep normal bg
    
    def apply_preferences(self, updated_prefs):
        self.preferences = updated_prefs
        save_preferences(updated_prefs)
        self._apply_coupled_limits() 
    
    def open_preferences(self):
        if self.pref_window is None or not self.pref_window.winfo_exists():
            self.pref_window = PreferencesDialog(self, self.preferences, self.apply_preferences)

    def on_closing(self):
        """Close child dialogs, stop timers, release figures and exit cleanly."""
        # Close the Preferences dialog if it is still open
        if getattr(self, "pref_window", None) and self.pref_window.winfo_exists():
            self.pref_window.destroy()

        # Cancel the delayed-call that updates the status bar (if scheduled)
        global _status_clear_job
        try:
            if _status_clear_job:
                self.after_cancel(_status_clear_job)          # stop pending .after
        except Exception:
            pass
        _status_clear_job = None

        # Close all matplotlib figures that live outside Tk‚Äôs control
        plt.close('all')

        # Destroy the Tk application and leave Python
        self.destroy()
        sys.exit(0)

    def _apply_coupled_limits(self):
        """Enforce (or release) the x-limit ‚Üî mask link."""
        coupled = self.preferences.get("couple_x_limits", "1") == "1"

        x_min, x_max         = state['x_min_entry'],  state['x_max_entry']
        mask_min, mask_max   = state['x_min_mask_entry'], state['x_max_mask_entry']
        target_state         = "disabled" if coupled else "normal"

        # --- helper -------------------------------------------------------------
        def copy_limits_into_masks():
            mask_min.config(state="normal")
            mask_max.config(state="normal")
            mask_min.delete(0, tk.END); mask_min.insert(0, x_min.get())
            mask_max.delete(0, tk.END); mask_max.insert(0, x_max.get())
            mask_min.config(state=target_state)
            mask_max.config(state=target_state)

        # (re)wire whenever x-limits change
        for ent in (x_min, x_max):
            ent.bind("<KeyRelease>", lambda e: coupled and copy_limits_into_masks())

        # initial application
        copy_limits_into_masks() if coupled else (
            mask_min.config(state="normal"),
            mask_max.config(state="normal") )

    # ------------------------------------------------------------
    # Build all widgets (frames, buttons, entries, canvas, etc.)
    # ------------------------------------------------------------
    def _build_gui(self):

        self.state = state

        # DATA INPUT FRAME
        data_frame = ttk.LabelFrame(self, text="Data Import")
        data_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10, rowspan=2, columnspan=2)

        data_tree = ttk.Treeview(data_frame, show="tree")
        data_tree.column("#0", width=300, stretch=True, anchor='w')
        data_tree.grid(row=0, column=0, sticky="nsew", padx=5, columnspan=5)
        
        add_dir_btn = ttk.Button(data_frame ,text="Add New Dir", command=lambda: add_dirs(data_tree))
        add_dir_btn.grid(row=1, column=0, sticky="", padx=5, pady=5)

        load_cache_btn = ttk.Button(data_frame, text="Load Cached Scan",
                            command=lambda: load_cached_dir_tree(data_tree))
        load_cache_btn.grid(row=1, column=1, sticky="", padx=5, pady=5)

        remove_dir_btn = ttk.Button(data_frame, text="Remove Dir", command=lambda: remove_dir(data_tree))
        remove_dir_btn.grid(row=1, column=2, sticky="", padx=5, pady=5)

        clear_dirs_btn = ttk.Button(data_frame, text="Clear all", command=lambda: clear_dirs(data_tree))
        clear_dirs_btn.grid(row=1, column=3, sticky="", padx=5, pady=5)

        add_workspace_btn = ttk.Button(data_frame, text="Add to Plot Workspace", command=lambda: add_to_workspace(data_tree, workspace_tree))
        add_workspace_btn.grid(row=1, column=4, sticky="", padx=5, pady=5, ipady=5)

        _init_status_bar(data_frame)
        
        # WORKSPACE FRAME
        workspace_frame = ttk.LabelFrame(self, text="Plot Workspace")
        workspace_frame.grid(row=2, column=0, sticky="nsew", padx=10, pady=10, rowspan=2, columnspan=2)   

        workspace_tree = ttk.Treeview(workspace_frame, show="tree")
        workspace_tree.column("#0", width=300, anchor='w')
        workspace_tree.grid(row=0, column=0, sticky="nsew", padx=5, columnspan=4)

        move_up_btn = ttk.Button(workspace_frame, text="‚Üë", command=lambda: move_up(workspace_tree))
        move_up_btn.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)

        move_down_btn = ttk.Button(workspace_frame, text="‚Üì", command=lambda: move_down(workspace_tree))
        move_down_btn.grid(row=1, column=1, sticky="nsew", padx=5, pady=5)

        remove_workspace_btn = ttk.Button(workspace_frame, text="Remove", command=lambda: remove_from_workspace(workspace_tree))
        remove_workspace_btn.grid(row=1, column=2, sticky="nsew", padx=5, pady=5)

        clear_workspace_btn = ttk.Button(workspace_frame, text="Clear", command=lambda: clear_workspace(workspace_tree))
        clear_workspace_btn.grid(row=1, column=3, sticky="nsew", padx=5, pady=5)

        plot_data_btn = ttk.Button(workspace_frame,
                                text="Plot Spectrum",
                                command=lambda: plot_graph(state),
                                state='disabled',
                                style="Plot.TButton")
        plot_data_btn.grid(row=2, column=0, columnspan=4, sticky="nsew", padx=5, pady=(15,5), ipady=5)
        self.widgets['plot_data_btn'] = plot_data_btn
        state['plot_data_btn']        = plot_data_btn

        workspace_frame.grid_rowconfigure(2, weight=1)   # give the new row stretch

        # ACTION FRAME
        action_frame = ttk.LabelFrame(self, text="Templates and Preferences")
        action_frame.grid(row=4, column=0, sticky="nsew", padx=10, pady=10, rowspan=1, columnspan=2)

        import_btn = ttk.Button(action_frame, text="Import Template", command=lambda: import_plot_template(state, initial_dir=self.preferences["template_dir"]))
        import_btn.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)

        export_btn = ttk.Button(action_frame, text="Save Current as Template", command=lambda: export_plot_template(state))
        export_btn.grid(row=0, column=1, sticky="nsew", padx=5, pady=5)

        preferences_btn = ttk.Button(action_frame, text="Preferences", command=self.open_preferences)
        preferences_btn.grid(row=0, column=2, sticky="nsew", padx=5, pady=5)

        _init_tpl_status_bar(action_frame)

        # CANVAS FRAME
        canvas_frame = ttk.LabelFrame(self, text="Plot")
        canvas_frame.grid(row=0, column=2, sticky="nsew", rowspan=5, columnspan=2, padx=10, pady=10)

        # container with two rows: toolbar (row 0) and canvas (row 1)
        plot_container = ttk.Frame(canvas_frame)
        plot_container.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)

        toolbar_frame = ttk.Frame(plot_container)
        toolbar_frame.grid(row=0, column=0, sticky="ew")

        canvas_holder = ttk.Frame(plot_container)
        canvas_holder.grid(row=1, column=0, sticky="nsew")

        # make the canvas row stretch
        plot_container.grid_rowconfigure(1, weight=1)
        plot_container.grid_columnconfigure(0, weight=1)

        # keep the outer frame stretchy too
        canvas_frame.grid_rowconfigure(0, weight=1)
        canvas_frame.grid_columnconfigure(0, weight=1)
        

        # PLOTTING PARAMETERS (Customization) FRAME
        customization_frame = ttk.LabelFrame(self, text="Plotting Parameters")
        customization_frame.grid(row=5, column=0, sticky="nsew", padx=10, pady=10, columnspan=4)

        # column 1

        x_axis_unit_label = ttk.Label(customization_frame, text="X-Axis Unit:").grid(row=0, column=0, sticky="w", padx=10, pady=5)
        x_axis_unit = tk.StringVar()
        x_axis_unit_combobox = ttk.Combobox(customization_frame, textvariable=x_axis_unit, values=["ppm","Hz","kHz"], width=5)
        x_axis_unit_combobox.grid(row=0, column=1, sticky="w", padx=8, pady=5)
        
        x_min_label = ttk.Label(customization_frame, text="X-Min:").grid(row=1, column=0, sticky="w", padx=10, pady=5)
        x_min_entry = ttk.Entry(customization_frame, width=6)
        x_min_entry.grid(row=1, column=1, sticky="w", padx=10, pady=5)

        x_max_label = ttk.Label(customization_frame, text="X-Max:").grid(row=2, column=0, sticky="w", padx=10, pady=5)
        x_max_entry = ttk.Entry(customization_frame, width=6)
        x_max_entry.grid(row=2, column=1, sticky="w", padx=10, pady=5)

        x_min_mask_label = ttk.Label(customization_frame, text="X-Min Mask:").grid(row=3, column=0, sticky="w", padx=10, pady=5)
        x_min_mask_entry = ttk.Entry(customization_frame, width=6)
        x_min_mask_entry.grid(row=3, column=1, sticky="w", padx=10, pady=5)

        x_max_mask_label = ttk.Label(customization_frame, text="X-Max Mask:").grid(row=4, column=0, sticky="w", padx=10, pady=5)
        x_max_mask_entry = ttk.Entry(customization_frame, width=6)
        x_max_mask_entry.grid(row=4, column=1, sticky="w", padx=10, pady=5)

        # column 2

        nucleus_label = ttk.Label(customization_frame, text="Nucleus:").grid(row=0, column=2, sticky="w", padx=10, pady=5)
        nucleus_entry = ttk.Entry(customization_frame, width=6)
        nucleus_entry.grid(row=0, column=3, sticky="w", padx=10, pady=5)

        y_min_label = ttk.Label(customization_frame, text="Y-Min:").grid(row=1, column=2, sticky="w", padx=10, pady=5)
        y_min_entry = ttk.Entry(customization_frame, width=6)
        y_min_entry.grid(row=1, column=3, sticky="w", padx=10, pady=5)

        y_max_label = ttk.Label(customization_frame, text="Y-Max:").grid(row=2, column=2, sticky="w", padx=10, pady=5)
        y_max_entry = ttk.Entry(customization_frame, width=6)
        y_max_entry.grid(row=2, column=3, sticky="w", padx=10, pady=5)

        scaling_factor_label = ttk.Label(customization_frame, text="Scaling Factor:").grid(row=3, column=2, sticky="w", padx=10, pady=5)
        scaling_factor_entry = ttk.Entry(customization_frame, width=6)
        scaling_factor_entry.grid(row=3, column=3, sticky="w", padx=10, pady=5)

        whitespace_label = ttk.Label(customization_frame, text="Whitespace:").grid(row=4, column=2, sticky="w", padx=10, pady=5)
        whitespace_entry = ttk.Entry(customization_frame, width=6)
        whitespace_entry.grid(row=4, column=3, sticky="w", padx=10, pady=5)

        # column 3

        label_font_type_label = ttk.Label(customization_frame, text="Axis Label Font Type:").grid(row=0, column=4, sticky="w", padx=10, pady=5)
        label_font_type_var = tk.StringVar()
        label_font_type_combobox = ttk.Combobox(customization_frame, values=["Arial", "Times New Roman", "Courier New"], textvariable=label_font_type_var, width=5, state="readonly")
        label_font_type_combobox.grid(row=0, column=5, sticky="w", padx=8, pady=5)

        label_font_size_label = ttk.Label(customization_frame, text="Axis Label Font Size:").grid(row=1, column=4, sticky="w", padx=10, pady=5)
        label_font_size_entry = ttk.Entry(customization_frame, width=6)
        label_font_size_entry.grid(row=1, column=5, sticky="w", padx=10, pady=5)
        
        line_thickness_label = ttk.Label(customization_frame, text="Line Thickness:").grid(row=2, column=4, sticky="w", padx=10, pady=5)
        line_thickness_entry = ttk.Entry(customization_frame, width=6)
        line_thickness_entry.grid(row=2, column=5, sticky="w", padx=10, pady=5)
        
        color_scheme_label = ttk.Label(customization_frame, text="Color Scheme:").grid(row=3, column=4, sticky="w", padx=10, pady=5)
        color_scheme_var = tk.StringVar()
        color_scheme_combobox = ttk.Combobox(customization_frame, values=["Default", "Scheme1", "Scheme2", "Scheme3", "Custom"], textvariable=color_scheme_var, width=5, state="readonly")
        color_scheme_combobox.grid(row=3, column=5, sticky="w", padx=8, pady=5)
        color_scheme_combobox.current(0)

        custom_color_label = ttk.Label(customization_frame, text="Custom Color:").grid(row=4, column=4, sticky="w", padx=10, pady=5)
        custom_color_entry = ttk.Entry(customization_frame, width=6)
        custom_color_entry.grid(row=4, column=5, sticky="w", padx=10, pady=5)


        # column 4

        axis_font_type_label = ttk.Label(customization_frame, text="Tick Label Font Type:").grid(row=0, column=6, sticky="w", padx=10, pady=5)
        axis_font_type_var = tk.StringVar()
        axis_font_type_combobox = ttk.Combobox(customization_frame, values=["Arial", "Times New Roman", "Courier New"], textvariable=axis_font_type_var, width=5, state="readonly")
        axis_font_type_combobox.grid(row=0, column=7, sticky="w", padx=8, pady=5)
        axis_font_type_combobox.current(0)   # default = Arial

        axis_font_size_label = ttk.Label(customization_frame, text="Tick Label Font Size:").grid(row=1, column=6, sticky="w", padx=10, pady=5)
        axis_font_size_entry = ttk.Entry(customization_frame, width=6)
        axis_font_size_entry.grid(row=1, column=7, sticky="w", padx=10, pady=5)

        mode_label = ttk.Label(customization_frame, text="Mode:").grid(row=2, column=6, sticky="w", padx=10, pady=5)
        mode_var = tk.StringVar()
        mode_combobox = ttk.Combobox(customization_frame, values=["stack", "overlay"], textvariable=mode_var, width=5, state="readonly")
        mode_combobox.grid(row=2, column=7, sticky="w", padx=8, pady=5)
        mode_combobox.current(0)

        x_offset_label = ttk.Label(customization_frame, text="X-Offset:").grid(row=3, column=6, sticky="w", padx=10, pady=5)
        x_offset_entry = ttk.Entry(customization_frame, width=6)
        x_offset_entry.grid(row=3, column=7, sticky="w", padx=10, pady=5)

        y_offset_label = ttk.Label(customization_frame, text="Y-Offset:").grid(row=4, column=6, sticky="w", padx=10, pady=5)
        y_offset_entry = ttk.Entry(customization_frame, width=6)
        y_offset_entry.grid(row=4, column=7, sticky="w", padx=10, pady=5)


        # column 5

        major_ticks_freq_label = ttk.Label(customization_frame, text="Major Ticks Spacing:").grid(row=0, column=8, sticky="w", padx=10, pady=5)
        major_ticks_freq_entry = ttk.Entry(customization_frame, width=6)
        major_ticks_freq_entry.grid(row=0, column=9, sticky="w", padx=10, pady=5)

        minor_ticks_freq_label = ttk.Label(customization_frame, text="Minor Ticks Interval:").grid(row=1, column=8, sticky="w", padx=10, pady=5)
        minor_ticks_freq_entry = ttk.Entry(customization_frame, width=6)
        minor_ticks_freq_entry.grid(row=1, column=9, sticky="w", padx=10, pady=5)

        major_ticks_len_label = ttk.Label(customization_frame, text="Major Ticks Length:").grid(row=2, column=8, sticky="w", padx=10, pady=5)
        major_ticks_len_entry = ttk.Entry(customization_frame, width=6)
        major_ticks_len_entry.grid(row=2, column=9, sticky="w", padx=10, pady=5)

        minor_ticks_len_label = ttk.Label(customization_frame, text="Minor Ticks Length:").grid(row=3, column=8, sticky="w", padx=10, pady=5)
        minor_ticks_len_entry = ttk.Entry(customization_frame, width=6)
        minor_ticks_len_entry.grid(row=3, column=9, sticky="w", padx=10, pady=5)
        
        
        # Configure the main grid
        self.grid_rowconfigure(0, weight=1, minsize=50)  # Row for Data Frame and Canvas (Canvas is on right side row 0)
        self.grid_rowconfigure(2, weight=1, minsize=50)  # Row for Workspace
        self.grid_rowconfigure(4, weight=1, minsize=70)  # Row for Actions
        self.grid_rowconfigure(5, weight=1, minsize=200)  # Row for Customization

        self.grid_columnconfigure(0, weight=1, uniform="half")  # Column for Data Import, Workspace, Actions, Customization
        self.grid_columnconfigure(2, weight=2, uniform="half")  # Column for Canvas Frame

        # Configure the frames
        data_frame.grid_rowconfigure(0, weight=1)  # Allow the data tree to expand
        data_frame.grid_rowconfigure(1, weight=0)   # Add-Dir / Load-Cache / ‚Ä¶ buttons
        for col in range(4):
            data_frame.grid_columnconfigure(col, weight=1)  # Allow the buttons to expand

        workspace_frame.grid_rowconfigure(0, weight=1)  # Allow the workspace tree to expand
        workspace_frame.grid_rowconfigure(1, weight=0)   # ‚Üë/‚Üì/Remove/Clear buttons
        workspace_frame.grid_rowconfigure(2, weight=0)   # Plot Spectrum button (stays visible)
        for col in range(4):
            workspace_frame.grid_columnconfigure(col, weight=1)  # Allow the buttons to expand

        action_frame.grid_rowconfigure(0, weight=0)  # Allow the action buttons to expand
        for col in range(4):
            action_frame.grid_columnconfigure(col, weight=1)  # Allow the buttons to expand
        
        canvas_frame.grid_rowconfigure(0, weight=1)  # Allow the canvas to expand
        canvas_frame.grid_columnconfigure(0, weight=1)  # Allow the canvas to expand

        # Customization Options Expansion
        for col in range(10): 
            customization_frame.grid_columnconfigure(col, weight=1)  # Allow all columns to expand

        for row in range(5):
            customization_frame.grid_rowconfigure(row, weight=1)

        # Store all GUI elements in the state dictionary
        state['data_tree'] = data_tree
        state['workspace_tree'] = workspace_tree
        state['canvas_holder'] = canvas_holder
        state['toolbar_frame'] = toolbar_frame 
        show_empty_plot(state)
        state['canvas_frame'] = canvas_frame
        state['x_min_entry'] = x_min_entry
        state['x_max_entry'] = x_max_entry
        state['y_min_entry'] = y_min_entry
        state['y_max_entry'] = y_max_entry
        state['x_axis_unit'] = x_axis_unit
        state['x_min_mask_entry'] = x_min_mask_entry
        state['x_max_mask_entry'] = x_max_mask_entry
        state['mode_var'] = mode_var
        state['x_offset_entry'] = x_offset_entry
        state['y_offset_entry'] = y_offset_entry
        state['nucleus_entry'] = nucleus_entry
        state['color_scheme_var'] = color_scheme_var
        state['color_schemes'] = {
            "Default": ["black"],
            "Scheme1": ["red", "green", "blue", "cyan", "magenta", "yellow", "black"],
            "Scheme2": ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2"],
            "Scheme3": ["#17becf", "#bcbd22", "#7f7f7f", "#aec7e8", "#ffbb78", "#98df8a", "#ff9896"],
            "Custom": []  # This will be populated dynamically
        }
        state['custom_color_entry'] = custom_color_entry
        state['axis_font_type_var'] = axis_font_type_var
        state['axis_font_size_entry'] = axis_font_size_entry
        state['label_font_type_var'] = label_font_type_var
        state['label_font_size_entry'] = label_font_size_entry
        state['line_thickness_entry'] = line_thickness_entry
        state['scaling_factor_entry'] = scaling_factor_entry
        state['whitespace_entry'] = whitespace_entry
        state['major_ticks_freq_entry'] = major_ticks_freq_entry
        state['minor_ticks_freq_entry'] = minor_ticks_freq_entry
        state['major_ticks_len_entry'] = major_ticks_len_entry
        state['minor_ticks_len_entry'] = minor_ticks_len_entry

        self._apply_coupled_limits() 
    

def safe_float(text, default=None):
    # Utility: safe float conversion (blank or non-numeric ‚Üí default)
    try:
        return float(text)
    except (TypeError, ValueError):
        return default

def scan_bruker_structure(selected_dir):
    """
    Validate a Bruker directory tree where the user selects the folder that
    directly contains sample folders.  Expected relative layout is:

        selected_dir/
            ‚îî‚îÄ‚îÄ <sample_name>/          (any string)
                ‚îî‚îÄ‚îÄ <expt#>/            (numeric)
                    ‚îî‚îÄ‚îÄ pdata/
                        ‚îî‚îÄ‚îÄ <proc#>/    (numeric)
                            ‚îî‚îÄ‚îÄ ascii-spec.txt

    On success returns (ascii_paths, True, set()).
    On mismatch returns (partial_paths, False, {"reason", ...}).
    """
    ascii_paths     = []
    structure_ok    = False
    bad_reasons     = set()
    expected_depth  = 4          # <sample> / <expt#> / pdata / <proc#>

    for root, dirs, files in os.walk(selected_dir):
        rel_parts = Path(root).relative_to(selected_dir).parts

        # We never need to look deeper than the proc folder
        if len(rel_parts) > expected_depth:
            dirs.clear()
            continue

        if "ascii-spec.txt" in files:
            depth = len(rel_parts)

            # Flag selections that are too high / low
            if depth != expected_depth:
                if depth > expected_depth:
                    bad_reasons.add(
                        f"Directory too HIGH ‚Äì ascii-spec.txt is {depth - expected_depth} "
                        f"level(s) deeper (e.g., {root})"
                    )
                else:
                    bad_reasons.add(
                        f"Directory too LOW ‚Äì you chose inside a sample/experiment folder (e.g., {root})"
                    )
                continue

            # depth == expected_depth ‚Üí detailed sanity checks
            sample, expt, pdata_dir, proc = rel_parts

            if not expt.isdigit():
                bad_reasons.add(f"Experiment folder '{expt}' is not numeric");   continue
            if pdata_dir != "pdata":
                bad_reasons.add(f"Expected 'pdata', found '{pdata_dir}' in {root}");   continue
            if not proc.isdigit():
                bad_reasons.add(f"Proc folder '{proc}' is not numeric");   continue

            ascii_paths.append(os.path.join(root, "ascii-spec.txt"))
            structure_ok = True        # at least one valid dataset found

        # Optional early test: stop descending into non-numeric experiment dirs
        if len(rel_parts) == 2 and not rel_parts[1].isdigit():
            dirs.clear()

    return ascii_paths, structure_ok, bad_reasons

def add_dirs(tree):
    """Directory selection + validation + loading, with strict Bruker folder structure checks."""
    global existing_data

    selected_dir = filedialog.askdirectory(
        initialdir=app.preferences["import_dir"],
        title="Select Data Directory"
    )
    if not selected_dir:
        return

    set_status(f"Scanning {os.path.basename(selected_dir)} ...")

    def worker():
        set_status(f"üîç Scanning {os.path.basename(selected_dir)}...")
        t0 = time.perf_counter()

        ascii_paths, valid, bad_reasons = scan_bruker_structure(selected_dir)
        elapsed = time.perf_counter() - t0

        def finalize():
            if not valid:
                if ascii_paths:
                    msg = "‚ö†Ô∏è Found ascii-spec.txt files but in unexpected structure:\n" + "\n".join(bad_reasons)
                else:
                    msg = "‚ùå No valid Bruker datasets found. Are you one level too high or too low?"
                set_status(msg)
                return

            # Re-run full directory parse if valid
            result = traverse_directory(selected_dir)
            for k, v in result.items():
                existing_data.setdefault(k, {}).update(v)
            populate_treeview(tree, existing_data)
            set_status(f"‚úÖ Loaded {len(ascii_paths)} ascii-spec.txt files in {elapsed:.1f}s")
            _save_dir_cache(selected_dir, ascii_paths)

        app.after(0, finalize)

    threading.Thread(target=worker, daemon=True).start()

def load_cached_dir_tree(tree):
    """
    Repopulate the Data-Import Treeview from last_scan.txt.

    For every directory that was cached we build:
        {basename(top_dir): {sample: {'Expt N, proc M': ascii_path}}}
    and pass that straight into populate_treeview().
    """
    blocks = _load_dir_cache()
    if not blocks:
        set_status("No cached scan found.")
        return

    tree.delete(*tree.get_children())        # clear current view
    tree_dict: dict[str, dict[str, dict[str,str]]] = {}

    for top_dir, ascii_files in blocks:
        samples: dict[str, dict[str, str]] = defaultdict(dict)

        for f in ascii_files:
            parts = Path(f).relative_to(top_dir).parts
            if len(parts) < 5:
                continue
            sample, expt, _, proc, _ = parts
            label = f"Expt {expt}, proc {proc}"
            samples[sample][label] = f

        # sort labels numerically (Expt ‚Üí proc)
        for samp, sub in samples.items():
            samples[samp] = dict(sorted(
                sub.items(),
                key=lambda kv: (int(kv[0].split()[1].rstrip(',')),
                                int(kv[0].split()[3]))
            ))

        tree_dict[os.path.basename(top_dir)] = samples

    populate_treeview(tree, tree_dict)
    global existing_data
    existing_data.clear()
    existing_data.update(tree_dict)
    set_status(f"‚úÖ Loaded cached scans from {len(blocks)} folder(s)", 4000)

def traverse_directory(root_dir):
    """Traverse a directory and organize experiment data."""
    result = {}
    
    for root, dirs, files in os.walk(root_dir):
        # Skip hidden directories and files
        dirs[:] = [d for d in dirs if not d.startswith('.')]
        files = [f for f in files if not f.startswith('.')]

        # Determine the relative path and its components
        rel_path = os.path.relpath(root, root_dir)
        parts = rel_path.split(os.sep)

        if len(parts) == 1:  # Experiment folder level
            experiment_folder = parts[0]
            if experiment_folder not in result:
                result[experiment_folder] = {}  # Initialize the folder in the result
        elif "ascii-spec.txt" in files:  # Valid data condition
            exp_num = extract_proc_number(root)
            proc_num = extract_experiment_number(root)
            combined_key = f"Expt {exp_num}, proc {proc_num}"
            
            experiment_folder = parts[0]
            result[experiment_folder][combined_key] = os.path.join(root, "ascii-spec.txt")

    # Sort the keys by proc_num and then by expt_num
    for experiment_folder in result:
        sorted_keys = sorted(
            result[experiment_folder].keys(),
            key=lambda x: (
                int(x.split()[1].replace(",", "")),  # Extract proc_num and remove comma
                int(x.split()[3])  # Extract expt_num
        ))
        result[experiment_folder] = {k: result[experiment_folder][k] for k in sorted_keys}

    # Remove experiment folders that have no valid children
    valid_result = {
        folder: children
        for folder, children in result.items()
        if children  # Keep only folders with valid child nodes
    }
    
    return {os.path.basename(root_dir): valid_result}


def extract_experiment_number(dir_path):
    """Return the Bruker experiment number folder

    Falls back to None if the path is too shallow instead of raising IndexError.
    """
    parts = dir_path.split(os.sep)
    return parts[-3] if len(parts) >= 3 else None


def extract_proc_number(dir_path):
    """Extract the proc number from a directory path."""
    parts = dir_path.split(os.sep)
    return parts[-1]


def populate_treeview(tree, data):
    """Populate the Treeview with hierarchical data."""
    def insert_items(parent, items):
        for key, value in items.items():
            if not key or key in ('.', '..'):  # Skip invalid entries
                continue
            if isinstance(value, dict):
                # Folder node
                node = tree.insert(parent, "end", text=key, values=(key,))
                insert_items(node, value)
            else:
                # Leaf node
                tree.insert(parent, "end", text=key, values=(value,))
    
    tree.delete(*tree.get_children())
    insert_items('', data)

def add_to_workspace(data_tree, workspace_tree):
    """Add selected leaf items from the data tree to the workspace tree
       and report all messages in the status bar instead of the terminal."""
    selected_items = data_tree.selection()
    if not selected_items:
        set_status("No items selected", 4000)
        return

    added = 0  # track how many valid datasets we manage to copy

    for s in selected_items:
        # Reject anything that still has children ‚Üí it's a folder
        if data_tree.get_children(s):
            set_status(f"‚ö†Ô∏è  '{data_tree.item(s)['text']}' is a folder; select individual datasets.",
                       5000)
            continue

        full_path = data_tree.item(s)['values'][0]

        # Dataset must end in ascii-spec.txt
        if not full_path.endswith("ascii-spec.txt"):
            set_status(f"‚ö†Ô∏è  '{data_tree.item(s)['text']}' is not a valid dataset.", 5000)
            continue

        # ---- build the display label -------------------------------------------------
        proc_folder   = extract_proc_number(os.path.dirname(full_path))
        expt_folder   = extract_experiment_number(os.path.dirname(full_path))
        sample_folder = os.path.basename(
            os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(full_path))))
        )
        display_name = f"{sample_folder} / expt {expt_folder} / proc {proc_folder}"

        workspace_tree.insert("", "end", text=display_name, values=(full_path,))
        added += 1

    # (Enable the Plot button only if something got added)
    if added and 'plot_data_btn' in state:
        state['plot_data_btn'].config(state='normal')

    # Final feedback
    if added:
        set_status(f"‚úÖ  Added {added} dataset{'s' if added > 1 else ''} to workspace", 4000)
    else:
        # If nothing valid was added, the most recent warning is still showing
        pass

# def add_to_workspace(data_tree, workspace_tree):
#     """Add selected items from the data tree to the workspace tree."""
#     selected_items = data_tree.selection()
#     if not selected_items:
#         print("No items selected")
#         return
    
#     for s in selected_items:
#         if data_tree.get_children(s):
#             print(f"Item {data_tree.item(s)['text']} is not a leaf node and cannot be added.")
#             continue

#         full_path = data_tree.item(s)['values'][0]

#         # Check if the path points to a valid `ascii-spec.txt`
#         if not full_path.endswith("ascii-spec.txt"):
#             print(f"Item {data_tree.item(s)['text']} is invalid (not a valid leaf node).")
#             continue

#         # Extract parts of the path
#         proc_folder = extract_proc_number(os.path.dirname(full_path))
#         expt_folder = extract_experiment_number(os.path.dirname(full_path))
#         sample_folder = os.path.basename(os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(full_path)))))

#         # Construct display label
#         display_name = f"{sample_folder} / expt {expt_folder} / proc {proc_folder}"

#         workspace_tree.insert("", "end", text=display_name, values=(full_path,))

#         # Enable the plot button if something is added
#         if 'plot_data_btn' in state:
#             state['plot_data_btn'].config(state='normal')
        
#         clear_status()


def remove_dir(data_tree):
    """Remove the selected top-level directory from the data import treeview."""
    selected_items = data_tree.selection()
    for item in selected_items:
        parent = data_tree.parent(item)
        # Ensure only top-level items are removed
        if not parent:
            data_tree.delete(item)
        else:
            print(f"Cannot remove {data_tree.item(item)['text']} as it is not a top-level item.")


def clear_dirs(data_tree):
    """Remove all top-level directories from the data import treeview."""
    top_level_items = data_tree.get_children()
    for item in top_level_items:
        data_tree.delete(item)


def remove_from_workspace(tree):
    """Remove the selected items from the workspace tree."""
    selected_items = tree.selection()
    for item in selected_items:
        tree.delete(item)
    # Disable Plot button if workspace is now empty
    if not tree.get_children():
        if 'plot_data_btn' in state:
            state['plot_data_btn'].config(state='disabled')


def clear_workspace(tree):
    """Remove all items from the workspace tree."""
    for item in tree.get_children():
        tree.delete(item)
    if 'plot_data_btn' in state:
        state['plot_data_btn'].config(state='disabled')


def move_up(tree):
    """Move the selected item up in the treeview."""
    selected_items = tree.selection()
    if not selected_items:
        return  # No item selected

    for item in selected_items:
        index = tree.index(item)
        if index > 0:  # Ensure it isn't already at the top
            parent = tree.parent(item)
            tree.move(item, parent, index - 1)


def move_down(tree):
    """Move the selected item down in the treeview."""
    selected_items = tree.selection()
    if not selected_items:
        return  # No item selected

    for item in selected_items:
        index = tree.index(item)
        parent = tree.parent(item)
        children = tree.get_children(parent)
        if index < len(children) - 1:  # Ensure it isn't already at the bottom
            tree.move(item, parent, index + 1)


def plot_graph(state):
    """Plot the data based on the current state."""
    set_tpl_status("")          # clear template messages
    gather_data(state)
    transform_data(state)
    customize_graph(state)


def gather_data(state):
    """Gather data from the workspace tree and prepare it for plotting."""
    state['file_paths'] = [state['workspace_tree'].item(child)["values"][0] for child in state['workspace_tree'].get_children()]
    state['lines'] = []

    for file_path in state['file_paths']:
        df = pd.read_csv(file_path, skiprows=1)
        # Choose Y column based on the selected x_axis_unit
        if state['x_axis_unit'].get() == "ppm":
            x_column_index = 3
        elif state['x_axis_unit'].get() == "Hz" or state['x_axis_unit'].get() == "kHz":
            x_column_index = 2
            if state['x_axis_unit'].get() == "kHz":
                # Divide y values by 1000 for kHz
                df.iloc[:, x_column_index] /= 1000
        else:
            print("Invalid x-axis unit")
        x_data = df.iloc[:, x_column_index]
        max_y_value = float(df.iloc[:, 1].max())
        if app.preferences.get("disable_int_norm", "0") == "1":
            y_data = df.iloc[:, 1]            # raw
        else:
            y_data = df.iloc[:, 1] / max_y_value

        # Apply data limits
        if app.preferences.get("couple_x_limits", "1") == "1":
            data_x_min = float(state['x_min_entry'].get()) if state['x_min_entry'].get() else x_data.min()
            data_x_max = float(state['x_max_entry'].get()) if state['x_max_entry'].get() else x_data.max()
        else:
            data_x_min = float(state['x_min_mask_entry'].get()) if state['x_min_mask_entry'].get() else x_data.min()
            data_x_max = float(state['x_max_mask_entry'].get()) if state['x_max_mask_entry'].get() else x_data.max()
        
        mask = (x_data <= data_x_max) & (x_data >= data_x_min)
        x_data = x_data[mask]
        y_data = y_data[mask]

        state['lines'].append([x_data, y_data])  # [[x1,y1],[x2,y2],[x3,y3]...]


def transform_data(state):
    """Transform the data based on user-defined settings (scaling, offsets, etc.)."""
    scaling_factor_str = state['scaling_factor_entry'].get()
    scaling_factor = float(scaling_factor_str) if scaling_factor_str and scaling_factor_str.replace('.', '', 1).isdigit() else 1.0

    x_offset_increment = float(state['x_offset_entry'].get()) if state['x_offset_entry'].get() else 0
    y_offset_increment = float(state['y_offset_entry'].get()) if state['y_offset_entry'].get() else 0
    
    cumulative_y_offset = 0  # Initialize cumulative y-offset for stacking

    for idx, line in enumerate(state['lines']):
        # Apply scaling factor to y-data
        line[1] *= scaling_factor
        
        if state['mode_var'].get().lower() == "overlay":
            # Apply x and y offsets (increases as index increases)
            line[0] += x_offset_increment * idx
            line[1] += y_offset_increment * idx
        elif state['mode_var'].get().lower() == "stack":
            if idx == 0:
                # First line remains at base level
                cumulative_y_offset = max(line[1]) + y_offset_increment
            else:
                # Store original max before modification
                original_max = max(line[1])
                # Apply cumulative offset to current line
                line[1] += cumulative_y_offset
                # Update cumulative offset with original max + spacing
                cumulative_y_offset += original_max + y_offset_increment


def customize_graph(state):
    """Customize and display the graph based on user settings."""
    clear_plot(state)

    fig, ax = plt.subplots()
    set_axis_limits(state, ax)
    axis_title = get_axis_title(state['nucleus_entry'].get(), state['x_axis_unit'].get())
    set_axis_ticks(state, ax)

    selected_scheme = state['color_scheme_var'].get()
    if selected_scheme == "Custom":
        custom_color = state['custom_color_entry'].get()
        if custom_color and validate_color(custom_color):
            colors = [custom_color]
        else:
            messagebox.showerror("Error", "Please enter a valid color name or hex code")
            return
    else:
        colors = state['color_schemes'].get(selected_scheme, state['color_schemes']["Default"])

    ax.set_xlabel(axis_title, fontdict={'family': state['label_font_type_var'].get() if state['label_font_type_var'].get() else 'Arial', 'size': float(state['label_font_size_entry'].get()) if state['label_font_size_entry'].get() else 10})

    for idx, line in enumerate(reversed(state['lines'])):
        line_color = colors[0] if selected_scheme == "Custom" else colors[idx % len(colors)]
        ax.plot(line[0], line[1], linewidth=float(state['line_thickness_entry'].get()) if state['line_thickness_entry'].get() else None, color=line_color)

    ax.invert_xaxis()
    fig.tight_layout()

    ph = state.pop('placeholder_canvas', None)
    if ph:
        try:
            ph.destroy()
        except Exception:
            pass


    # Embed canvas in the dedicated holder
    canvas = FigureCanvasTkAgg(fig, master=state['canvas_holder'])
    canvas.draw()
    canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)

    # Put toolbar in its own top row so it stays visible
    toolbar = CustomNavigationToolbar(canvas, state['toolbar_frame'])
    toolbar.update()

def show_empty_plot(state):
    """Show a responsive 'empty plot' placeholder in the plot area."""
    holder = state.get('canvas_holder')
    if not holder:
        return

    # Don't stack multiple placeholders
    if holder.winfo_children():
        return

    ph = tk.Canvas(holder, bg="white", highlightthickness=1, highlightbackground="#CCCCCC")
    ph.pack(side=tk.TOP, fill=tk.BOTH, expand=1)

    def _redraw(event):
        ph.delete("all")
        w, h = event.width, event.height
        m = 10
        # subtle inner rect so it reads as a panel even when tiny
        ph.create_rectangle(m, m, max(w-m, 0), max(h-m, 0), outline="#E0E0E0", fill="white")
        ph.create_text(w//2, h//2, text="Plot will appear here", fill="#9A9A9A")

    ph.bind("<Configure>", _redraw)
    state['placeholder_canvas'] = ph

def set_axis_limits(state, ax):
    """Set the axis limits based on user input."""
    x_min = float(state['x_min_entry'].get()) if state['x_min_entry'].get() else min(state['lines'][-1][0])
    x_max = float(state['x_max_entry'].get()) if state['x_max_entry'].get() else max(state['lines'][0][0])

    ax.set_xlim(x_min, x_max)
    
    y_min = float(state['y_min_entry'].get()) if state['y_min_entry'].get() else 0
    y_max = float(state['y_max_entry'].get()) if state['y_max_entry'].get() else 1

    if state['mode_var'].get() == "stack" and state['y_max_entry'].get() == '':
        y_max = max(state['lines'][-1][1])
    elif state['mode_var'].get() == "overlay" and state['y_max_entry'].get() == '':
        y_max = max(state['lines'][-1][1])

    # Retrieve the whitespace value entered by the user
    whitespace_value = float(state['whitespace_entry'].get()) if state['whitespace_entry'].get() else 0.1

    ax.set_ylim(y_min - whitespace_value, y_max + whitespace_value)

def get_axis_title(nucleus, x_axis_unit):
    """Generate the axis title based on the nucleus and x-axis unit."""
    if not nucleus:
        return

    if x_axis_unit == "ppm":
        unit_string = "Chemical Shift (ppm)"
    elif x_axis_unit == "Hz":
        unit_string = "Frequency (Hz)"
    elif x_axis_unit == "kHz":
        unit_string = "Frequency (kHz)"
    else:
        print("Invalid x-axis unit selection")
        return

    numeric_part = ""
    element_name = ""
    
    for i in range(0, len(nucleus)):
        if nucleus[i].isdigit():
            numeric_part += nucleus[i]
        else:
            element_name += nucleus[i]

    # Use LaTeX syntax for font styling
    title_with_superscript = r"$\mathregular{^{%s}}$%s %s" % (numeric_part, element_name, unit_string)

    return title_with_superscript

def set_axis_ticks(state, ax):
    """Set the axis ticks based on user input."""
    x_ticks_spacing = safe_float(state['major_ticks_freq_entry'].get()) if state['major_ticks_freq_entry'].get() else None
    x_minor_ticks_spacing = safe_float(state['minor_ticks_freq_entry'].get()) if state['minor_ticks_freq_entry'].get() else None

    if x_ticks_spacing is not None:
        ax.xaxis.set_major_locator(ticker.MultipleLocator(x_ticks_spacing))

    if x_minor_ticks_spacing is not None:
        ax.xaxis.set_minor_locator(ticker.MultipleLocator(x_minor_ticks_spacing))

    # Set font properties directly on the x-axis tick labels
    font_properties = {
        # use Axis-font combobox; default to Arial if blank
        'family': state['axis_font_type_var'].get() if state['axis_font_type_var'].get() else 'Arial',
        'size'  : float(state['axis_font_size_entry'].get()) if state['axis_font_size_entry'].get() else 10
    }

    # Hide y-axis ticks and labels
    ax.yaxis.set_major_locator(plt.NullLocator())
    ax.yaxis.set_minor_locator(plt.NullLocator())

    # Additional customization

    major_len = safe_float(state['major_ticks_len_entry'].get()) or 4.0
    minor_len = safe_float(state['minor_ticks_len_entry'].get()) or 2.0

    # length & size
    ax.tick_params(axis='x',
                   which='major', length=major_len, labelsize=font_properties['size'])
    ax.tick_params(axis='x',
                   which='minor', length=minor_len, labelsize=font_properties['size'])

    # family
    for lbl in ax.get_xticklabels():
        lbl.set_family(font_properties['family'])


def clear_plot(state):
    """Clear the current plot and toolbar, then show placeholder."""
    holder = state.get('canvas_holder')
    if holder:
        for w in holder.winfo_children():
            w.destroy()

    tbar = state.get('toolbar_frame')
    if tbar:
        for w in tbar.winfo_children():
            w.destroy()

    plt.close('all')

    # Recreate the empty plot box
    show_empty_plot(state)


def validate_color(color):
    """Validate if the color is a valid name or hex code."""
    try:
        plt.plot([], color=color)
        return True
    except ValueError:
        return False


def export_plot_template(state):
    """Export settings while excluding GUI widgets."""
    
    file = filedialog.asksaveasfilename(initialdir=app.preferences["template_dir"],defaultextension='.txt')
    if file:
        exportable_state = {}
        
        # Collect only the values we want to export
        for widget_name, widget in state.items():
            if isinstance(widget, tk.Entry):
                exportable_state[widget_name] = widget.get()
            elif isinstance(widget, tk.StringVar):
                exportable_state[widget_name] = widget.get()
            elif widget_name not in ['data_tree', 'workspace_tree', 'placeholder_canvas', 
                                   'canvas_frame', 'color_schemes', 'lines', 'file_paths']:
                exportable_state[widget_name] = str(widget)
        
        with open(file, 'w') as f:
            for key, value in exportable_state.items():
                f.write(f"{key}:{value}\n")
        
        set_tpl_status("‚úÖ  Template saved")

def import_plot_template(state, initial_dir=None, file_path=None):
    if initial_dir is None:
        initial_dir = app.preferences.get("template_dir", ".")
    # ------------------------------------------------------------------ #
    # 1) get the pathname
    template_path = filedialog.askopenfilename(
        title="Import Template",
        filetypes=[("Text files", "*.txt")],
        initialdir=initial_dir
    )
    if not template_path:                     # user hit ‚ÄúCancel‚Äù
        set_tpl_status("No template file selected")
        return
    # ------------------------------------------------------------------ #
    try:
        # 2) open the file          ‚Üê NEW
        with open(template_path, "r", encoding="utf-8") as fh:
            for line_number, line in enumerate(fh, 1):
                if not line.strip():
                    continue

                if ':' not in line:
                    print(f"Warning: Line {line_number} is malformed (missing colon): {line.strip()}")
                    continue

                key, value = line.strip().split(":", 1)
                if not key or not value:
                    print(f"Warning: Line {line_number} has empty key or value: {line.strip()}")
                    continue

                if key in state:
                    if isinstance(state[key], tk.Entry):
                        state[key].delete(0, tk.END)
                        state[key].insert(0, value)
                    elif isinstance(state[key], tk.StringVar):
                        state[key].set(value)
                    elif key not in ['data_tree', 'workspace_tree', 'placeholder_canvas',
                                     'canvas_frame', 'color_schemes']:
                        try:
                            state[key] = value
                        except Exception as e:
                            print(f"Warning: Could not import value for {key}: {str(e)}")
                else:
                    print(f"Warning: Unknown key in settings file: {key}")

        set_tpl_status(f"‚úÖ  Template loaded ({os.path.basename(template_path)})")

    except Exception as e:
        set_tpl_status("Failed to load template")
        print(f"Template import error: {e}")

if __name__ == "__main__":
    app = NMRPlotterApp()
    app.mainloop()